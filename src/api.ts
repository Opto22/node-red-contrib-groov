/**
 * groov Public API
 * #### Revised: 2016-08-31  ### Overview groov Public API revision 1. 
 *
 * OpenAPI spec version: R3.3a
 * Contact: developer@opto22.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import request = require('request');
import http = require('http');
import Promise = require('bluebird');

let defaultBasePath = 'https://localhost/api';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */


export class TagValue
{
    'valueType': TagValue.ValueTypeEnum;
}

export namespace TagValue
{
    export enum ValueTypeEnum
    {
        TagValueBoolean = <any>'tagValueBoolean',
        IntegerValue = <any>'integerValue',
        FloatValue = <any>'floatValue',
        StringValue = <any>'stringValue',
        BooleanArrayValue = <any>'booleanArrayValue',
        IntegerArrayValue = <any>'integerArrayValue',
        FloatArrayValue = <any>'floatArrayValue',
        StringArrayValue = <any>'stringArrayValue',
        ErrorValue = <any>'errorValue'
    }
}

export class BooleanValue extends TagValue
{
}

export namespace BooleanValue
{
}
export class BooleanValueArray extends TagValue
{
}

export namespace BooleanValueArray
{
}


export class Device
{
    //'deviceType': Device.DeviceTypeEnum;
}

export class DataStoreDevice extends Device
{
}

export namespace DataStoreDevice
{
}


export class ErrorValue extends TagValue
{
}

export namespace ErrorValue
{
}
export class FloatArrayValue extends TagValue
{
}

export namespace FloatArrayValue
{
}
export class FloatValue extends TagValue
{
}

export namespace FloatValue
{
}
export class IntegerArrayValue extends TagValue
{
}

export namespace IntegerArrayValue
{
}
export class IntegerValue extends TagValue
{
}

export namespace IntegerValue
{
}
export class StringArrayValue extends TagValue
{
}

export namespace StringArrayValue
{
}
export class StringValue extends TagValue
{
}

export namespace StringValue
{
}
export class TagDefinition
{
    'id': number;
    'deviceId': number;
    'name': string;
    'length': number;
    'dataType': TagDefinition.DataTypeEnum;
}

export namespace TagDefinition
{
    export enum DataTypeEnum
    {
        Boolean = <any>'boolean',
        Integer = <any>'integer',
        Float = <any>'float',
        String = <any>'string',
        BooleanArray = <any>'booleanArray',
        IntegerArray = <any>'integerArray',
        FloatArray = <any>'floatArray',
        StringArray = <any>'stringArray'
    }
}
export class TagReference
{
    /**
    * Unique id for the tag.
    */
    'id': number;
    /**
    * For array tags, the index to start reading at.
    */
    'index': number;
    /**
    * For array tags, the number of elements to read, starting at index.
    */
    'count': number;
}



export interface Authentication
{
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: request.Options): void;
}

export class HttpBasicAuth implements Authentication
{
    public username: string;
    public password: string;
    applyToRequest(requestOptions: request.Options): void
    {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

export class ApiKeyAuth implements Authentication
{
    public apiKey: string;

    constructor(private location: string, private paramName: string)
    {
    }

    applyToRequest(requestOptions: request.Options): void
    {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header") {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

export class OAuth implements Authentication
{
    public accessToken: string;

    applyToRequest(requestOptions: request.Options): void
    {
        requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
    }
}

export class VoidAuth implements Authentication
{
    public username: string;
    public password: string;
    applyToRequest(requestOptions: request.Options): void
    {
        // Do nothing
    }
}

export enum DatastoreApiApiKeys
{
    api_key,
}

export class DatastoreApi
{
    protected basePath = defaultBasePath;
    protected defaultHeaders: any = {};
    protected _useQuerystring: boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'api_key': new ApiKeyAuth('query', 'api_key'),
    }

    // constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string)
    {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean)
    {
        this._useQuerystring = value;
    }

    public setApiKey(key: DatastoreApiApiKeys, value: string)
    {
        this.authentications[DatastoreApiApiKeys[key]].apiKey = value;
    }
    private extendObj<T1, T2>(objA: T1, objB: T2)
    {
        for (let key in objB) {
            if (objB.hasOwnProperty(key)) {
                objA[key] = objB[key];
            }
        }
        return <T1 & T2>objA;
    }
    /**
     * 
     * List tags of the given device.
     * @param id ID of the device to use.
     */
    public dataStoreListDeviceTags(id: number): Promise<{ response: http.ClientResponse; body: Array<TagDefinition>; }>
    {
        const localVarPath = this.basePath + '/v1/data-store/devices/{id}/tags'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling dataStoreListDeviceTags.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.api_key.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<TagDefinition>; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * List devices available in the data store.
     */
    public dataStoreListDevices(): Promise<{ response: http.ClientResponse; body: Array<DataStoreDevice>; }>
    {
        const localVarPath = this.basePath + '/v1/data-store/devices';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.api_key.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<DataStoreDevice>; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * List all data store tags defined in the project.
     */
    public dataStoreListTags(): Promise<{ response: http.ClientResponse; body: Array<TagDefinition>; }>
    {
        const localVarPath = this.basePath + '/v1/data-store/tags';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.api_key.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<TagDefinition>; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Read the current value of a single tag.
     * @param id ID of the tag to read.
     * @param index Table index to start reading at.
     * @param count Number of elements to read from a table.
     */
    public dataStoreReadSingleTag(id: number, index?: number, count?: number): Promise<{ response: http.ClientResponse; body: TagValue; }>
    {
        const localVarPath = this.basePath + '/v1/data-store/read/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling dataStoreReadSingleTag.');
        }

        if (index !== undefined) {
            queryParameters['index'] = index;
        }

        if (count !== undefined) {
            queryParameters['count'] = count;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.api_key.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TagValue; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Read selected tags from the data store.
     * @param tags Tag references for the tags to read.
     */
    public dataStoreReadTags(tags: Array<TagReference>): Promise<{ response: http.ClientResponse; body: TagValue; }>
    {
        const localVarPath = this.basePath + '/v1/data-store/read';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'tags' is not null or undefined
        if (tags === null || tags === undefined) {
            throw new Error('Required parameter tags was null or undefined when calling dataStoreReadTags.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: tags,
        };

        this.authentications.api_key.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TagValue; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Writes a new value to the given tag.
     * @param id ID of the tag to write.
     * @param value Value to write to the tag. Must be a string, number, or boolean.
     * @param index For array tags, the index to write the value to.
     */
    public dataStoreWriteSingleTag(id: number, value: string, index?: number): Promise<{ response: http.ClientResponse; body: TagValue; }>
    {
        const localVarPath = this.basePath + '/v1/data-store/write/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling dataStoreWriteSingleTag.');
        }

        // verify required parameter 'value' is not null or undefined
        if (value === null || value === undefined) {
            throw new Error('Required parameter value was null or undefined when calling dataStoreWriteSingleTag.');
        }

        if (value !== undefined) {
            queryParameters['value'] = value;
        }

        if (index !== undefined) {
            queryParameters['index'] = index;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.api_key.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TagValue; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
